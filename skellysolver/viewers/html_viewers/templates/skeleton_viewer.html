<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skeleton Trajectory Viewer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: system-ui, -apple-system, sans-serif;
            background: #0a0a0a;
            color: white;
            overflow: hidden;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        #canvas-container {
            flex: 1;
            position: relative;
            min-height: 100px;
        }
        
        #controls {
            background: #1a1a1a;
            border-top: 2px solid #333;
            padding: 15px 20px;
            flex-shrink: 0;
        }
        
        .control-row {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }
        
        button {
            padding: 10px 20px;
            background: #2563eb;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }
        
        button:hover { background: #1d4ed8; }
        button.reset { background: #4b5563; }
        button.reset:hover { background: #374151; }
        
        input[type="range"] {
            flex: 1;
            min-width: 150px;
        }
        
        label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            user-select: none;
        }
        
        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .text-sm { font-size: 14px; color: #9ca3af; }
        
        #info-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 8px;
            font-size: 13px;
            max-width: 300px;
            backdrop-filter: blur(10px);
        }
        
        .info-row {
            margin-bottom: 6px;
            color: #9ca3af;
        }
        
        .info-label {
            color: #60a5fa;
            font-weight: 600;
            display: inline-block;
            min-width: 80px;
        }
        
        .color-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 2px;
            margin-right: 6px;
            vertical-align: middle;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container">
            <div id="info-panel">
                <div class="info-row">
                    <span class="info-label">Skeleton:</span>
                    <span id="info-name">-</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Keypoints:</span>
                    <span id="info-keypoints">-</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Frames:</span>
                    <span id="info-frames">-</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Segments:</span>
                    <span id="info-segments">-</span>
                </div>
            </div>
        </div>

        <div id="controls">
            <div class="control-row">
                <button id="playBtn">▶ Play</button>
                <button class="reset" id="resetBtn">↺ Reset</button>
                <input type="range" id="frameSlider" min="0" max="0" value="0">
                <span class="text-sm">
                    <span id="currentFrame">0</span> / <span id="totalFrames">0</span>
                </span>
            </div>

            <div class="control-row">
                <label>
                    <input type="checkbox" id="showRaw" checked>
                    <span class="color-indicator" style="background: #f87171;"></span>
                    <span>Raw</span>
                </label>
                <label>
                    <input type="checkbox" id="showOptimized" checked>
                    <span class="color-indicator" style="background: #60a5fa;"></span>
                    <span>Optimized</span>
                </label>
                <label id="gtLabel" style="display: none;">
                    <input type="checkbox" id="showGroundTruth">
                    <span class="color-indicator" style="background: #4ade80;"></span>
                    <span>Ground Truth</span>
                </label>
                <label>
                    <input type="checkbox" id="showGrid" checked>
                    <span>Grid</span>
                </label>
                <label>
                    <input type="checkbox" id="autoRotate">
                    <span>Auto-Rotate</span>
                </label>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // EMBEDDED DATA - replaced during generation
        const VIEWER_DATA = __VIEWER_DATA_JSON__;

        // Parse data
        const topology = VIEWER_DATA.topology;
        const frames = VIEWER_DATA.frames;
        const N_FRAMES = VIEWER_DATA.n_frames;
        const HAS_OPTIMIZED = VIEWER_DATA.has_optimized;
        const HAS_GT = VIEWER_DATA.has_ground_truth;

        // State
        let currentFrame = 0;
        let isPlaying = false;
        let showRaw = true;
        let showOptimized = true;
        let showGroundTruth = false;
        let showGrid = true;
        let autoRotate = false;

        let scene, camera, renderer, controls;
        let rawGroup, optimizedGroup, gtGroup, gridHelper;
        let playInterval = null;

        const KEYPOINT_COLORS = [
            0xff4444, 0x44ff44, 0x4444ff, 0xffff44,
            0xff44ff, 0x44ffff, 0xff8844, 0x88ff44,
            0xaa44ff, 0x44aaff, 0xffaa44, 0xaaff44
        ];

        // Simple OrbitControls
        class OrbitControls {
            constructor(camera, domElement) {
                this.camera = camera;
                this.domElement = domElement;
                
                const STATE = { NONE: -1, ROTATE: 0, PAN: 2 };
                let state = STATE.NONE;
                
                const rotateStart = new THREE.Vector2();
                const rotateEnd = new THREE.Vector2();
                const rotateDelta = new THREE.Vector2();
                const panStart = new THREE.Vector2();
                const panEnd = new THREE.Vector2();
                const panDelta = new THREE.Vector2();
                
                const spherical = new THREE.Spherical();
                const sphericalDelta = new THREE.Spherical();
                let scale = 1;
                const panOffset = new THREE.Vector3();
                const target = new THREE.Vector3();

                const rotateLeft = (angle) => { sphericalDelta.theta -= angle; };
                const rotateUp = (angle) => { sphericalDelta.phi -= angle; };

                const pan = (deltaX, deltaY) => {
                    const offset = new THREE.Vector3();
                    offset.copy(this.camera.position).sub(target);
                    let targetDistance = offset.length();
                    targetDistance *= Math.tan((this.camera.fov / 2) * Math.PI / 180.0);
                    
                    const v = new THREE.Vector3();
                    v.setFromMatrixColumn(this.camera.matrix, 0);
                    v.multiplyScalar(-2 * deltaX * targetDistance / this.domElement.clientHeight);
                    panOffset.add(v);
                    
                    v.setFromMatrixColumn(this.camera.matrix, 1);
                    v.multiplyScalar(2 * deltaY * targetDistance / this.domElement.clientHeight);
                    panOffset.add(v);
                };

                const dollyIn = (dollyScale) => { scale /= dollyScale; };
                const dollyOut = (dollyScale) => { scale *= dollyScale; };

                this.update = () => {
                    const offset = new THREE.Vector3();
                    offset.copy(this.camera.position).sub(target);
                    
                    const quat = new THREE.Quaternion().setFromUnitVectors(
                        camera.up, 
                        new THREE.Vector3(0, 1, 0)
                    );
                    const quatInverse = quat.clone().invert();
                    
                    offset.applyQuaternion(quat);
                    spherical.setFromVector3(offset);
                    spherical.theta += sphericalDelta.theta;
                    spherical.phi += sphericalDelta.phi;
                    spherical.phi = Math.max(0.01, Math.min(Math.PI - 0.01, spherical.phi));
                    spherical.makeSafe();
                    spherical.radius *= scale;
                    
                    target.add(panOffset);
                    offset.setFromSpherical(spherical);
                    offset.applyQuaternion(quatInverse);
                    
                    this.camera.position.copy(target).add(offset);
                    this.camera.lookAt(target);
                    
                    sphericalDelta.set(0, 0, 0);
                    panOffset.set(0, 0, 0);
                    scale = 1;
                };

                const onMouseDown = (event) => {
                    event.preventDefault();
                    if (event.button === 0) {
                        rotateStart.set(event.clientX, event.clientY);
                        state = STATE.ROTATE;
                    } else if (event.button === 2) {
                        panStart.set(event.clientX, event.clientY);
                        state = STATE.PAN;
                    }
                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                };

                const onMouseMove = (event) => {
                    event.preventDefault();
                    if (state === STATE.ROTATE) {
                        rotateEnd.set(event.clientX, event.clientY);
                        rotateDelta.subVectors(rotateEnd, rotateStart);
                        rotateLeft(2 * Math.PI * rotateDelta.x / this.domElement.clientHeight);
                        rotateUp(2 * Math.PI * rotateDelta.y / this.domElement.clientHeight);
                        rotateStart.copy(rotateEnd);
                        this.update();
                    } else if (state === STATE.PAN) {
                        panEnd.set(event.clientX, event.clientY);
                        panDelta.subVectors(panEnd, panStart);
                        pan(panDelta.x, panDelta.y);
                        panStart.copy(panEnd);
                        this.update();
                    }
                };

                const onMouseUp = () => {
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    state = STATE.NONE;
                };

                const onMouseWheel = (event) => {
                    event.preventDefault();
                    if (event.deltaY < 0) dollyOut(0.95);
                    else if (event.deltaY > 0) dollyIn(0.95);
                    this.update();
                };

                domElement.addEventListener('mousedown', onMouseDown);
                domElement.addEventListener('wheel', onMouseWheel);
                domElement.addEventListener('contextmenu', (e) => e.preventDefault());
            }
        }

        function initThreeJS() {
            const container = document.getElementById('canvas-container');
            const width = container.clientWidth;
            const height = container.clientHeight;

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);

            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            camera.position.set(3, 3, 3);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            container.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            scene.add(directionalLight);

            rawGroup = new THREE.Group();
            optimizedGroup = new THREE.Group();
            gtGroup = new THREE.Group();

            scene.add(rawGroup);
            scene.add(optimizedGroup);
            scene.add(gtGroup);

            gridHelper = new THREE.GridHelper(10, 20, 0x444444, 0x222222);
            scene.add(gridHelper);

            function animate() {
                requestAnimationFrame(animate);
                if (autoRotate) {
                    const time = Date.now() * 0.0001;
                    camera.position.x = 3 * Math.cos(time);
                    camera.position.z = 3 * Math.sin(time);
                    camera.lookAt(0, 0, 0);
                }
                controls.update();
                renderer.render(scene, camera);
            }
            animate();

            window.addEventListener('resize', () => {
                const w = container.clientWidth;
                const h = container.clientHeight;
                camera.aspect = w / h;
                camera.updateProjectionMatrix();
                renderer.setSize(w, h);
            });
        }

        function parseFrameData(frame, prefix) {
            const points = [];
            for (const kpName of topology.keypoint_names) {
                const x = frame[`${prefix}_${kpName}_x`];
                const y = frame[`${prefix}_${kpName}_y`];
                const z = frame[`${prefix}_${kpName}_z`];
                
                if (x !== undefined && y !== undefined && z !== undefined) {
                    points.push(new THREE.Vector3(x, y, z));
                } else {
                    points.push(null);
                }
            }
            return points;
        }

        function createSkeleton(points, color, edgeOpacity = 0.6) {
            const group = new THREE.Group();

            // Create keypoint spheres
            points.forEach((p, i) => {
                if (p === null) return;
                
                const geometry = new THREE.SphereGeometry(0.06, 16, 16);
                const material = new THREE.MeshStandardMaterial({
                    color: KEYPOINT_COLORS[i % KEYPOINT_COLORS.length]
                });
                const sphere = new THREE.Mesh(geometry, material);
                sphere.position.copy(p);
                group.add(sphere);
            });

            // Create rigid edges (solid lines)
            topology.rigid_edges.forEach(([i, j]) => {
                if (points[i] === null || points[j] === null) return;
                
                const linePoints = [points[i], points[j]];
                const geometry = new THREE.BufferGeometry().setFromPoints(linePoints);
                const material = new THREE.LineBasicMaterial({
                    color: color,
                    opacity: edgeOpacity,
                    transparent: true,
                    linewidth: 2
                });
                const line = new THREE.Line(geometry, material);
                group.add(line);
            });

            // Create flexible edges (dashed lines)
            topology.flexible_edges.forEach(([i, j, rigidity]) => {
                if (points[i] === null || points[j] === null) return;
                
                const linePoints = [points[i], points[j]];
                const geometry = new THREE.BufferGeometry().setFromPoints(linePoints);
                const material = new THREE.LineDashedMaterial({
                    color: color,
                    opacity: edgeOpacity * 0.7,
                    transparent: true,
                    linewidth: 1,
                    dashSize: 0.1,
                    gapSize: 0.05
                });
                const line = new THREE.Line(geometry, material);
                line.computeLineDistances();
                group.add(line);
            });

            return group;
        }

        function updateVisualization() {
            rawGroup.clear();
            optimizedGroup.clear();
            gtGroup.clear();

            const frame = frames[currentFrame];

            if (showRaw) {
                const rawPoints = parseFrameData(frame, 'raw');
                const rawSkeleton = createSkeleton(rawPoints, 0xff4444, 0.6);
                rawGroup.add(rawSkeleton);
            }

            if (showOptimized && HAS_OPTIMIZED) {
                const optimizedPoints = parseFrameData(frame, 'optimized');
                const optimizedSkeleton = createSkeleton(optimizedPoints, 0x4444ff, 0.7);
                optimizedGroup.add(optimizedSkeleton);
            }

            if (showGroundTruth && HAS_GT) {
                const gtPoints = parseFrameData(frame, 'gt');
                const gtSkeleton = createSkeleton(gtPoints, 0x44ff44, 0.8);
                gtGroup.add(gtSkeleton);
            }

            gridHelper.visible = showGrid;
            document.getElementById('currentFrame').textContent = currentFrame;
        }

        // Event listeners
        document.getElementById('playBtn').addEventListener('click', () => {
            isPlaying = !isPlaying;
            document.getElementById('playBtn').innerHTML = isPlaying ? '⏸ Pause' : '▶ Play';

            if (isPlaying) {
                playInterval = setInterval(() => {
                    currentFrame = (currentFrame + 1) % N_FRAMES;
                    document.getElementById('frameSlider').value = currentFrame;
                    updateVisualization();
                }, 33);
            } else {
                clearInterval(playInterval);
            }
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            currentFrame = 0;
            isPlaying = false;
            clearInterval(playInterval);
            document.getElementById('playBtn').innerHTML = '▶ Play';
            document.getElementById('frameSlider').value = 0;
            updateVisualization();
        });

        document.getElementById('frameSlider').addEventListener('input', (e) => {
            currentFrame = parseInt(e.target.value);
            updateVisualization();
        });

        document.getElementById('showRaw').addEventListener('change', (e) => {
            showRaw = e.target.checked;
            updateVisualization();
        });

        document.getElementById('showOptimized').addEventListener('change', (e) => {
            showOptimized = e.target.checked;
            updateVisualization();
        });

        document.getElementById('showGroundTruth').addEventListener('change', (e) => {
            showGroundTruth = e.target.checked;
            updateVisualization();
        });

        document.getElementById('showGrid').addEventListener('change', (e) => {
            showGrid = e.target.checked;
            updateVisualization();
        });

        document.getElementById('autoRotate').addEventListener('change', (e) => {
            autoRotate = e.target.checked;
        });

        // Initialize
        document.getElementById('frameSlider').max = N_FRAMES - 1;
        document.getElementById('totalFrames').textContent = N_FRAMES - 1;
        document.getElementById('info-name').textContent = topology.name;
        document.getElementById('info-keypoints').textContent = topology.keypoint_names.length;
        document.getElementById('info-frames').textContent = N_FRAMES;
        document.getElementById('info-segments').textContent = topology.metadata.n_segments;

        if (HAS_GT) {
            document.getElementById('gtLabel').style.display = 'flex';
        }

        initThreeJS();
        updateVisualization();
    </script>
</body>
</html>
